In .NET Core, there are two main approaches to interacting with a database using Entity Framework Core (EF Core): **Code First** and **Database First**. Both approaches allow you to work with databases in different ways, depending on your project's needs.

### 1. **Code First Approach**

In the **Code First** approach, you define your application's domain model (entities) and EF Core will automatically create the database schema based on your model.

#### Workflow:
1. **Create Classes (Domain Model):** You define the classes (entities) that represent the structure of your database tables.
   
2. **Configure EF Core (DbContext):** You create a `DbContext` class that holds the configuration for EF Core and maps the domain models to database tables.
   
3. **Migrations:** After the models are defined, you use **Migrations** to generate and update the database schema based on your model.
   
4. **Database Creation/Update:** You can use `Update-Database` or `dotnet ef database update` commands to create or update the database.

#### Key Features:
- **Migrations:** EF Core allows you to manage schema changes with migrations.
- **Flexibility:** Changes to the model are easily applied to the database with code.
- **No Initial Database:** The database is generated by EF Core based on the model.

#### Example:

```csharp
public class Product
{
    public int ProductId { get; set; }
    public string Name { get; set; }
    public decimal Price { get; set; }
}

public class AppDbContext : DbContext
{
    public DbSet<Product> Products { get; set; }

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.UseSqlServer("your_connection_string");
    }
}
```

Run migration commands to create the database:
```
dotnet ef migrations add InitialCreate
dotnet ef database update
```

### 2. **Database First Approach**

In the **Database First** approach, the database schema is already defined, and you generate the EF Core models based on the existing database schema.

#### Workflow:
1. **Existing Database:** You have an existing database schema with tables, relationships, and constraints.
   
2. **Scaffold Models:** Using EF Core's **scaffolding** tool, you generate the domain models and `DbContext` from the existing database schema.
   
3. **Use the Generated Models:** You can then use these generated models to interact with the database in your application.

#### Key Features:
- **Reverse Engineering:** The database schema is reverse-engineered into entity classes and a `DbContext`.
- **No Need for Migrations:** The database schema already exists and is managed outside EF Core.
- **Useful for Legacy Databases:** Ideal when working with an already defined schema.

#### Example:

To scaffold the database into EF Core models, use the following command:

```
dotnet ef dbcontext scaffold "your_connection_string" Microsoft.EntityFrameworkCore.SqlServer -o Models
```

This will generate a `DbContext` and entity classes based on your database schema.

#### Comparison:

| **Feature**               | **Code First**                           | **Database First**                        |
|---------------------------|------------------------------------------|-------------------------------------------|
| **Initial Development**    | Define models in code, generate DB later | Use an existing database                  |
| **Schema Changes**         | Managed through migrations               | Schema changes must be done in the DB     |
| **Control Over Schema**    | Full control over the database schema    | Database schema is pre-defined            |
| **Best Suited For**        | Greenfield projects (new applications)   | Legacy databases or pre-existing databases|

Both approaches can be useful, and your choice depends on whether you're building a new application or working with an existing database.